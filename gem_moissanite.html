<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gemini Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #watermark {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 20;
            font-family: 'Courier New', Courier, monospace;
            font-weight: 100;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.2);
            letter-spacing: 4px;
            pointer-events: none;
            border-left: 2px solid rgba(0, 255, 255, 0.4);
            padding-left: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        #watermark span {
            display: block;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.1);
            letter-spacing: 2px;
            margin-top: 5px;
        }
        #ui-layer {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 30px;
            pointer-events: none;
            align-items: flex-end;
        }
        button {
            pointer-events: auto;
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #ffd700;
            padding: 15px 40px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            border-radius: 2px;
            transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        button:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.2);
        }
        button:active {
            transform: scale(0.98);
        }
        
        .control-group {
            pointer-events: auto;
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 10px;
            border-radius: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .control-group:hover {
            border-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
        }
        .control-label {
            color: rgba(0, 255, 255, 0.7);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 30px;
            height: 30px;
            cursor: pointer;
            background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
        }

        #hud {
            position: absolute;
            top: 30px;
            right: 30px;
            text-align: right;
            color: rgba(255, 255, 255, 0.6);
            z-index: 10;
            pointer-events: none;
        }
        .data-row {
            margin-bottom: 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            opacity: 0.8;
        }
        .label { color: #666; }
        .val { color: #ffd700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
    </style>
</head>
<body>

    <div id="watermark">
        GEMINI
        <span>PHYSICS LAB v2.0</span>
    </div>

    <div id="hud">
        <div class="data-row"><span class="label">MATERIAL_ID ::</span> <span class="val">SiC (MOISSANITE)</span></div>
        <div class="data-row"><span class="label">GEOMETRY ::</span> <span class="val">BRILLIANT_CUT</span></div>
        <div class="data-row"><span class="label">REFRACTIVE_IDX ::</span> <span class="val">2.65-2.69</span></div>
        <div class="data-row"><span class="label">DISPERSION ::</span> <span class="val">0.104 (HIGH)</span></div>
        <div class="data-row"><span class="label">SUPPORT ::</span> <span class="val">Au 24kt</span></div>
        <div class="data-row"><span class="label">ACTIVE_PHOTONS ::</span> <span class="val" id="photon-count">0</span></div>
    </div>

    <div id="ui-layer">
        <button id="btn-launch">Inject Photon</button>
        
        <div class="control-group">
            <span class="control-label">Ambiance</span>
            <input type="color" id="led-color-picker" value="#00ffff">
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Import Three.js and Post-Processing -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Configuration ---
        const CONFIG = {
            gemIOR: 2.65, 
            sphereRadius: 40,
            gravity: 0, 
            photonSpeed: 0.9,
            maxPhotons: 100, // Increased for spectacle
            goldRoughness: 0.1,
            goldMetalness: 1.0,
            goldColor: 0xFFD700
        };

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202);
        // Deep space fog
        scene.fog = new THREE.FogExp2(0x020202, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 10, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // Antialias false for post-processing performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = CONFIG.sphereRadius - 2;
        controls.enablePan = false;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Post-Processing (Bloom) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Unreal Bloom for that sci-fi glow
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; // Start blooming at lower brightness
        bloomPass.strength = 1.2; // Intensity
        bloomPass.radius = 0.5; // Spread
        composer.addPass(bloomPass);

        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
        scene.add(ambientLight);

        // Main focused spot for the gem
        const spotLight = new THREE.SpotLight(0xffffff, 2000);
        spotLight.position.set(15, 30, 10);
        spotLight.angle = Math.PI / 8;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.bias = -0.0001;
        scene.add(spotLight);

        // --- Environment Details (Space Dust) ---
        const dustGeo = new THREE.BufferGeometry();
        const dustCount = 800;
        const dustPos = new Float32Array(dustCount * 3);
        for(let i=0; i<dustCount*3; i++) {
            dustPos[i] = (Math.random() - 0.5) * CONFIG.sphereRadius * 1.8;
        }
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
        const dustMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.15,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        const dustSystem = new THREE.Points(dustGeo, dustMat);
        scene.add(dustSystem);

        // --- 1. The Mirror Sphere ---
        const sphereGeo = new THREE.SphereGeometry(CONFIG.sphereRadius, 64, 64);
        const sphereMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            metalness: 0.95,
            roughness: 0.05,
            side: THREE.BackSide,
        });
        const mirrorSphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(mirrorSphere);

        // --- 2. The Gold Rod (Improved) ---
        const rodGeo = new THREE.CylinderGeometry(0.15, 0.4, 12, 32);
        const rodMat = new THREE.MeshStandardMaterial({
            color: CONFIG.goldColor,
            metalness: CONFIG.goldMetalness,
            roughness: CONFIG.goldRoughness,
            envMapIntensity: 2.0
        });
        const goldRod = new THREE.Mesh(rodGeo, rodMat);
        goldRod.position.y = -7;
        goldRod.castShadow = true;
        goldRod.receiveShadow = true;
        scene.add(goldRod);

        // Elegant Prongs
        const prongGeo = new THREE.CylinderGeometry(0.04, 0.02, 2.0, 16);
        const prongGroup = new THREE.Group();
        for(let i=0; i<6; i++) { // 6 prong setting for extra security/style
            const prong = new THREE.Mesh(prongGeo, rodMat);
            const angle = (i / 6) * Math.PI * 2;
            prong.position.set(Math.cos(angle)*0.85, 0, Math.sin(angle)*0.85);
            prong.rotation.x = 0.35;
            prong.rotation.y = -angle; 
            prongGroup.add(prong);
        }
        prongGroup.position.y = -1.2;
        scene.add(prongGroup);

        // --- 3. The Moissanite (Enhanced Geometry) ---
        function createEnhancedBrilliantGeometry() {
            // A stacked geometry approach for a better brilliant cut profile
            // Crown (Top)
            const crownGeo = new THREE.CylinderGeometry(1.2, 2.8, 1.2, 16, 1);
            crownGeo.translate(0, 0.6, 0);
            
            // Girdle (Middle)
            const girdleGeo = new THREE.CylinderGeometry(2.8, 2.8, 0.1, 16, 1);
            girdleGeo.translate(0, -0.05, 0);
            
            // Pavilion (Bottom)
            const pavilionGeo = new THREE.CylinderGeometry(2.8, 0.05, 2.4, 16, 1);
            pavilionGeo.translate(0, -1.3, 0);

            // Manual merge simulation for visual sharpness
            // We stick to a single geometry for physics to keep it fast, 
            // but for rendering we want sharp edges.
            
            const geometry = new THREE.CylinderGeometry(1.0, 0.0, 3.5, 32); 
            const pos = geometry.attributes.position;
            
            // Procedurally shaping the vertices to look like a cut gem
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z = pos.getZ(i);
                const r = Math.sqrt(x*x + z*z);
                
                // Top Table
                if (y > 1.0) {
                    pos.setY(i, 0.5);
                    // Widen table slightly
                    pos.setX(i, x * 1.5);
                    pos.setZ(i, z * 1.5);
                }
                // Girdle area
                else if (y > -0.5 && y < 0.5) {
                    const scale = 3.0;
                    pos.setX(i, x * scale);
                    pos.setZ(i, z * scale);
                    pos.setY(i, 0.0); // Flatten girdle
                }
                // Pavilion tip
                else if (y < -1.0) {
                    pos.setY(i, -2.5);
                }
            }
            geometry.computeVertexNormals();
            return geometry;
        }

        const gemGeo = createEnhancedBrilliantGeometry();
        
        const gemMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.0,
            transmission: 1.0, 
            thickness: 5.0,
            ior: CONFIG.gemIOR,
            reflectivity: 1.0,
            iridescence: 1.0, // New in recent Three.js, adds thin film interference
            iridescenceIOR: 1.3,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            side: THREE.DoubleSide,
            dispersion: 4.0, // If supported by browser/GPU
            attenuationColor: 0xffffff,
            attenuationDistance: 2.0
        });

        const moissanite = new THREE.Mesh(gemGeo, gemMat);
        moissanite.castShadow = true;
        scene.add(moissanite);

        // --- 4. Enhanced LED System ---
        const ledStrips = [];
        const ledMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            emissive: 0x00ffff,
            emissiveIntensity: 4.0, // High intensity for bloom
            roughness: 0.2,
            metalness: 0.8
        });

        function createLEDStrips() {
            const radius = CONFIG.sphereRadius - 1.5;
            const tubeRadius = 0.3;
            
            // 5 Rings for a "Cyber" look
            const latitudes = [0, 12, 24, -12, -24];
            
            latitudes.forEach((lat) => {
                const r = Math.sqrt(radius*radius - lat*lat);
                const geometry = new THREE.TorusGeometry(r, tubeRadius, 12, 64);
                geometry.rotateX(Math.PI / 2); 
                geometry.translate(0, lat, 0);
                
                const mesh = new THREE.Mesh(geometry, ledMat);
                scene.add(mesh);
                ledStrips.push(mesh);
            });
        }
        createLEDStrips();

        // --- 5. Advanced Physics Engine (Trail Photons) ---
        
        class TrailPhoton {
            constructor(scene, origin, velocity) {
                this.scene = scene;
                
                // Core Particle
                const geometry = new THREE.SphereGeometry(0.15, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 1.0, 0.7) 
                });
                this.mesh = new THREE.Mesh(geometry, material);
                
                // Point light for illumination
                this.light = new THREE.PointLight(material.color, 5, 8);
                this.mesh.add(this.light);

                this.mesh.position.copy(origin);
                this.velocity = velocity.clone().normalize().multiplyScalar(CONFIG.photonSpeed);
                
                this.scene.add(this.mesh);
                
                // Trail Setup
                this.trailPositions = [];
                this.maxTrailLength = 20;
                this.trailGeo = new THREE.BufferGeometry();
                this.trailMat = new THREE.LineBasicMaterial({
                    color: material.color,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                this.trailLine = new THREE.Line(this.trailGeo, this.trailMat);
                this.scene.add(this.trailLine);
                
                this.raycaster = new THREE.Raycaster();
                this.age = 0;
                this.maxAge = 500;
                this.active = true;
                this.insideGem = false;
                
                // Moissanite "Fire" Color Cycling
                this.baseHue = Math.random();
            }

            update(collidables) {
                if (!this.active) return;

                this.age++;
                if (this.age > this.maxAge) {
                    this.destroy();
                    return;
                }

                // Color Cycling for "Fire" effect
                const hue = (this.baseHue + (this.age * 0.005)) % 1;
                this.mesh.material.color.setHSL(hue, 1.0, 0.6);
                this.light.color.copy(this.mesh.material.color);
                this.trailLine.material.color.copy(this.mesh.material.color);

                // Movement
                const nextPos = this.mesh.position.clone().add(this.velocity);
                const direction = this.velocity.clone().normalize();
                const distance = this.velocity.length();

                // Raycast
                this.raycaster.set(this.mesh.position, direction);
                const intersects = this.raycaster.intersectObjects(collidables);

                if (intersects.length > 0 && intersects[0].distance <= distance) {
                    const hit = intersects[0];
                    const normal = hit.face.normal.clone().applyQuaternion(hit.object.quaternion).normalize();
                    
                    if (hit.object === moissanite) {
                        // Moissanite Physics
                        // High IOR = Smaller critical angle = More Trapped Light
                        // We simulate this by randomizing the bounce slightly more than a mirror
                        // to simulate facets we might have missed in the geometry
                        
                        // Birefringence check: Small chance to scatter velocity slightly
                        if (Math.random() > 0.8) {
                            normal.x += (Math.random() - 0.5) * 0.2;
                            normal.z += (Math.random() - 0.5) * 0.2;
                            normal.normalize();
                        }

                        this.velocity.reflect(normal);
                        
                        // Impact Flash
                        this.light.intensity = 15;
                        this.mesh.scale.setScalar(2.0);
                    } else {
                        // Standard Reflection
                        this.velocity.reflect(normal);
                        
                        // Absorb some energy (dim slightly on wall hit)
                        this.light.intensity *= 0.9;
                        
                        // LED interaction
                        if(ledStrips.includes(hit.object)) {
                            this.light.intensity = 8;
                            this.mesh.material.color.lerp(ledMat.emissive, 0.5);
                        }
                    }
                    
                    // Prevent sticking
                    this.mesh.position.copy(hit.point).add(normal.multiplyScalar(0.05));

                } else {
                    this.mesh.position.copy(nextPos);
                }
                
                // Relax flash
                this.light.intensity = THREE.MathUtils.lerp(this.light.intensity, 2, 0.1);
                this.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);

                // Update Trail
                this.trailPositions.push(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z);
                if (this.trailPositions.length > this.maxTrailLength * 3) {
                    this.trailPositions.splice(0, 3);
                }
                this.trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(this.trailPositions, 3));
            }

            destroy() {
                this.scene.remove(this.mesh);
                this.scene.remove(this.trailLine);
                this.trailGeo.dispose();
                this.active = false;
            }
        }

        const photons = [];
        const collidables = [mirrorSphere, moissanite, goldRod, ...ledStrips];

        // --- Interaction ---
        const btnLaunch = document.getElementById('btn-launch');
        const photonCountLabel = document.getElementById('photon-count');
        const ledColorPicker = document.getElementById('led-color-picker');

        // Inputs
        btnLaunch.addEventListener('click', (e) => { e.stopPropagation(); launchPhoton(); });
        btnLaunch.addEventListener('touchstart', (e) => { e.stopPropagation(); launchPhoton(); }, {passive: false});

        ledColorPicker.addEventListener('input', (e) => {
            const hex = e.target.value;
            const col = new THREE.Color(hex);
            ledMat.emissive.set(col);
        });

        // Auto-Interact (The "Autonomous" Kicker)
        // If user is idle, the system launches photons to keep the show going.
        let lastInteraction = Date.now();
        document.addEventListener('mousemove', () => lastInteraction = Date.now());
        document.addEventListener('click', () => lastInteraction = Date.now());

        function launchPhoton() {
            if (photons.length >= CONFIG.maxPhotons) {
                const old = photons.shift();
                old.destroy();
            }
            
            // Spawn from random points in the upper hemisphere towards center
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = CONFIG.sphereRadius - 10;
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = Math.abs(r * Math.cos(phi));
            const z = r * Math.sin(phi) * Math.sin(theta);
            
            const startPos = new THREE.Vector3(x, y, z);
            const target = new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2); // Aim generally at gem
            const velocity = new THREE.Vector3().subVectors(target, startPos).normalize();
            
            photons.push(new TrailPhoton(scene, startPos, velocity));
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();

            // Gem Rotation (Slow and majestic)
            moissanite.rotation.y = time * 0.15;
            moissanite.rotation.z = Math.sin(time * 0.5) * 0.05; // Slight wobble
            
            // LED Breathing
            const pulse = 3.0 + Math.sin(time * 1.5) * 1.5;
            ledMat.emissiveIntensity = pulse;
            
            // Dust Animation
            const positions = dustGeo.attributes.position.array;
            for(let i=0; i<dustCount; i++) {
                // Gentle float up
                positions[i*3 + 1] += 0.01; 
                if(positions[i*3 + 1] > 20) positions[i*3 + 1] = -20;
            }
            dustGeo.attributes.position.needsUpdate = true;
            dustSystem.rotation.y = time * 0.02;

            // Auto-fire logic
            if (Date.now() - lastInteraction > 2000) {
                // If idle for 2 seconds, fire occasionally
                if (Math.random() < 0.05) launchPhoton();
            }

            // Update Photons
            let activeCount = 0;
            photons.forEach(p => {
                if(p.active) {
                    p.update(collidables);
                    activeCount++;
                }
            });
            photonCountLabel.innerText = activeCount;

            // Cleanup
            for (let i = photons.length - 1; i >= 0; i--) {
                if (!photons[i].active) {
                    photons.splice(i, 1);
                }
            }

            controls.update();
            // Use Composer instead of Renderer for Bloom
            composer.render();
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial burst
        for(let i=0; i<5; i++) setTimeout(launchPhoton, i*200);

        animate();

    </script>
</body>
</html>